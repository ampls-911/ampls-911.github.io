[
  
  {
    "title": "TryHackMe | Cheese CTF",
    "url": "/posts/Cheese_CTF/",
    "categories": "TryHackMe",
    "tags": "thm, ctf, writeup",
    "date": "2025-08-20 03:00:00 +0100",
    "content": "Reconnaissance  In the reconnaissance phase, I started by using Nmap to enumerate the open ports. After a while, Nmap returned a very long list. We can see that a lot of ports of interest are open, such as HTTP and SSH.      We can access the webpage by visiting http://10.10.15.229:80/.    I tried enumerating folders, but it didn’t lead anywhere.    While browsing the site, we find a login page at http://10.10.15.229:80/login.php.    SQLi Authentication Bypass  I tried testing basic login credentials like admin:admin and admin:Password123, but nothing worked. So, I intercepted a login POST request using Burp Suite and tested it with SQLMap for SQL injection. SQLMap reported that the username parameter appeared to be injectable.      I initially tried to dump the database, which was successful and revealed a single user. However, the password hash associated with the user was uncrackable using online sites like CrackStation and others.    Knowing the username parameter was injectable, I tried some payloads, and eventually this one worked: ' || 1=1;-- -  This allowed us to bypass the authentication process.    LFI and RCE  Visiting the messages section of the site, we see a clickable link that takes us to a page with the message:    If you know, you know :D   Upon further inspection, we realize the URL is using a file parameter along with a filter:  http://10.10.15.229/secret-script.php?file=php://filter/resource=supersecretmessageforadmin  A simple test to try reading a world-readable file turns out to be successful.    We have an LFI!  We can use the convert.base64-encode filter to read the secret-script.php file like so:    To get a reverse shell, we need to use this tool: PHP filter chain generator  We set our Netcat listener and then create and send our payload.    And we have a shell!    User Flag  When we access the user comte’s home directory, we can access the .ssh folder and find an authorized_keys file.    Since the file is writable, we can generate an SSH key and add it to the file to get a shell as comte.      Now we connect via SSH:    Root Flag  When we check the sudo privileges for comte, we see:    The user can reload the configuration files for systemd and start a script called exploit.timer, which in turn starts the service exploit.service. Let’s see the script:    Let’s try running the script:    It won’t run! That’s because the OnBootSec= parameter is empty, which specifies to systemd when to start the timer after reload. Let’s add the missing value and execute the script.    Now, checking for binaries with the SUID bit set reveals a binary called xdd.    Looking it up on GTFOBins, we see that it can be abused to read files. We use it to read the flag:    "
  },
  
  {
    "title": "bwip",
    "url": "/posts/bwip/",
    "categories": "TryHackMe",
    "tags": "thm, ctf, walkthrough",
    "date": "2025-08-19 08:50:00 +0100",
    "content": "This is a test post to check if TryHackMe category works.  waaaaaaywa "
  }
  
]

